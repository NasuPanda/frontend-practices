# 7. Reactをめぐるフロントエンドの歴史

# 7-1. React 登場前夜

## 全てはGoogle Mapから始まった

Webフロントエンド元年と言えるのが2005年。
この年にGoogle Mapがリリースされた。

### Google Mapの何がすごかったのか

Google Mapはマウスのドラッグにより、見る位置を好きなように移動させたり、拡大・縮小させたりといったことがリアルタイムで出来た。
従来のインターネットの地図サービスは全てサーバーサイドアプリケーションで、移動・拡大しようとすると、静的リンクをクリックしてページ遷移する必要があり、非常にストレスフルだった。

Google Mapのようなインタラクティブなことをさせるには Flash などのプラグインを使うしか無かったが、それを HTML/JavaScript だけで実現してしまったことが衝撃的だった。
それまでJavaScriptはホームページを無意味に飾り付けるための言語だと思われていたが、Google Mapが再評価のきっかけとなった。

当時のGoogle Mapには Ajax(Asynchronous JavaScript + XML) という技術が使われた。

## フロントエンド第1世代

Google Map が Ajax を使っていたことから、 Ajax で高度なフロントエンドアプリケーションを作ろうという機運が高まっていった。

そして Google Map のリリースから3ヶ月後、最初に登場したのが Prototype JavaScript Framework 、 通常 **prototype.js** 。
Ajaxフレームワークを始めとしたJavaScriptアプリケーション開発のための様々な機能を提供するもの。

翌2006年には **JQuery** がリリース。
JavaScriptアプリ開発のためのユーティリティライブラリ群なのは prototype.js と変わらないが、DOM操作にブラウザ依存をなくした独自セレクタエンジンを採用していた。
当時はブラウザ間でJavaScriptの実装に無視できない差異があったため、それを吸収してくれる JQuery の利便性が評価され、広く使われるようになっていった。

Web フロントエンド開発のためのフレームワークや UI 構築ライブラリを世代分けするなら、 prototype.js や jQuery は第 1 世代といえる。
DOM 操作ライブラリを主軸としながら、確固としたアーキテクチャを持たないユーティリティライブラリ群の詰め合わせというのが共通する特徴。

### フロントエンド第1世代の HTML / JavaScript の動き

いっぽうこのようなフロントエンドの動向に呼応してか、しばらく安定していた Web や JavaScript の世界においても変化の動きが出てきた。
まず 2008 年に HTML5 のドラフトが発表される。 HTML5 は Adobe の Flash や Microsoft の Silverlight といったプロプライエタリなプラグインとして
提供されていたリッチなアプリケーションのプラットフォームを置き換えることを目的とし、Web アプリケーションのプラットフォームとしての機能や API を実装するための仕様。

すべてが固まって正式に勧告されたのは 2014 年だったが、主要なモダンブラウザは前倒しでどんどん対応を進めていき、2010 年ごろまでには仕様のほとんどがカバーされていた。
そうしてついに 2011 年 11 月、 Adobe は Flash Player の開発中止を発表するに至る。

JavaScriptの世界では2008年にGoggleが Chrome の JavaScriptエンジンであるV8をオープンソースとして公開。
翌2009年には V8 をエンジンに採用した Node.js がリリース。
さらに 1999年 を最後に更新されていなかったECMAScriptが2009年に ECMAScript 5th Edition、略称ES5 が発表された。

## フロントエンド第2世代

高度で複雑なアプリケーションをJavaScriptで作れる土壌が整ってきたが、明確なアーキテクチャが存在しない第1世代の技術でそれをやろうとすると、コードが無秩序に膨れ上がってしまう。
そこで、サーバーサイド開発で一般的だった MVC パターンをクライアントサイド向けにアレンジ・適用したフレームワークが出現。

第 2 世代における三大フレームワークが **Backbone.js** と **Knockout** 、 **AngularJS**。
なお、 AngularJS は現在の Angular と イコール ではない。Angular は名前だけ引き継いで作り直した互換性のない別フレームワーク。

# 7-2. Web Components が夢見たもの

## Web Components

2011年、Fronteers Conference 2011 において、Google のエンジニアで Chrome 開発チームのメンバーである Alex Russell が『Web Components and Model Driven Views』というテーマで講演をした。
その内容は HTML をプログラマブルに拡張し、開発者が自ら作成したカスタムタグを読み込んで使えるようにする Web Components という技術を Web 標準の仕様として広くブラウザに実装しようと提唱するもの。
従来用いられていたような、ひとつの長大な HTML と全体に適用されるこれまた長大な CSS をカプセル化された再利用可能なコンポーネントに分割し、それらの組み合わせで Web コンテンツを表現する仕組みを作ろうという提案だった。

これは野心的な提案だったが、ブラウザに実装するにはかなりコストがかかるもの。
ブラウザベンダー各社の合意を取るための調整が難航し、 Shadow DOM や Custom Elements が実装出来たのが2016年。

## React

React は Web Components のコアとなるアイデアを借用、それを既存のJavaScript技術を用いてライブラリの形にしたものと言える。

# 7-3. React の誕生

Facebookには **BoltJS** という内製のMVCフレームワークがあり、Facebook広告のアプリケーション開発に用いられていた。

問題が顕在化するにつれ、同社のエンジニアが BoltJS の欠点を克服するべく、個人で **FaxJS** という実験的プロジェクトを始めた。それが2011年のこと。

FaxJS は props や state 、コンポーネントなどの概念を盛り込んだ、いわばReact零号機。
そして、FaxJSの成果を Bolt にインポート、名前を FBolt (Functional Programming + BoltJS)とした。

が、すぐにいいライブラリ名では無いと思ったのか、 **React** という新しい名前を付けた。

## インスタとReactの関係

2012 年 4 月、Instagram が Facebook によって買収される。
Facebook のエンジニアが Instagram の Web 開発チームに合流して最初に始めたのが、Instagram の Web インターフェースを React で再構築することだった。
ただその時点での React は Facebook のインフラありきの設計になっていたため、React をそこから切り離して 完全に独立したプロダクトにする必要があった。
この作業が結果的に、React をオープンソース 化するために必要な作業の下準備となった。

2013年5月、Reactを一般に公開。
さらにその発表と同時にオープンソース化した。
ちなみにその時オープンした公式サイトは Instagram のデザイナーがデザインしたもの。
あの核反応をイメージしたロゴ、エレクトリックブルーのテーマカラーもそこで作られた。

# 7-4. Reactを読み解く 6 つのキーワード

- Declarative(宣言的)
- Component-Based(コンポーネントベース)
- Just The UI(UI にしか関知しない)
- Virtual DOM(仮想 DOM)
- One-Way Dataflow(単方向データフロー)
- Learn Once, Write Anywhere(ひとたび習得すれば、あらゆるプラットフォームで開発できる)

## Declarative (宣言的)

そもそも **宣言的** とは、宣言型プログラミングから来ている。
宣言型プログラミングは、出力の性質やあるべき状態を記述してプログラムを構成すること。わかりやすい例はSQL。

では、宣言的なフロントエンドとはどういうことか。
そこにどんなデータが表示されるべきか記述するだけでReactがそこにそのデータを表示し、適切なタイミングで適切な表示に更新してくれること。

コンポーネントをReact Elements としてマウントするぶんには宣言的に出来るが、肝心のコンポーネントの中身の実装が命令的にならざるを得ないのでは？
という問に対しては、従来はYes。現在はNo。

参照透過性を担保する関数型プログラミングは、出力値がプログラムのテキストから一律に決まるという性質により、宣言的プログラミングに分類される。
初期のReactはコンポーネントをクラスでしか表現出来なかったが、現在は純粋関数によりコンポーネントを表現出来るようになっているため、コンポーネントの実装も宣言的であると言える。

## Component-Based(コンポーネントベース)

コンポーネントベースのアーキテクチャとは、見た目と機能がカプセル化されたコンポーネントというアプリケーションの部品を作成し、それらを組み合わせることで複雑なUIを構築するという設計思想のこと。
Reactがアプリケーションの設計スタイルとして提示しているのはこれだけ。
データを扱うためにモデルが必要という思い込みを捨ててみると良いかも？

なお、他フレームワークは、Angular2以降はコンポーネントベース、Vue.jsはコンポーネントシステムとMVVMパターンを同時に備えていて、viewとmodelがコンポーネントに対して1対1であることが求められる。

## Just the UI(UIにしか関知しない)

Angular / Vue.js が「フレームワーク」を謳っているのに対し、Reactは一貫して「A JavaScript library for building user interface」と言い続けている。
実際、 React 単体でアプリケーションを構築することは難しく、サードーパーティのルーティングライブラリやグローバル状態管理ライブラリを別途導入する必要がある。

変化の早い世界では、ワンストップであることは逆に技術の進歩の妨げとなる。

## Virtual DOM(仮想DOM)

React Elements はコンポーネントを任意の props で呼ぶための実行リンクのようなもの。
その実行リンクは他の実行リンクを子要素として持つツリー構造になっている。
ルートのレンダリングが発火すると、そこからツリーを下っていった子孫の ReactElements からそのリンクされたユーザー定義コンポーネントのレンダリングが連鎖起爆され、最終的には HTML 要素に対応する組み込みコンポーネントの React Elements にまで展開しつくされたツリーが残る。
それがリアル DOM に変換されてブラウザが実際にレンダリングすることになるが、変換前の要素ツリーはメモリ上にキャッシュされる。
仮想DOM というのは、**メモリに展開されたこのイミュータブルな要素ツリー**のこと。

### React development tools

「React development tools」というChrome拡張機能を使うと、仮想DOMを可視化することが出来る。

## One-Way Dataflow(単方向データフロー)

Reactにおける単方向データフローとは、データがコンポーネントツリーを親から子に対して一方向に、 `props` という形をとって流れ落ちること。
子から親に向かってデータが逆流するということはない。

フォームを実装する際は、各パーツを子として持つ単一の親をまず作成する。
そしてその親でフォームデータを自身の `state` として持つ。

## Learn Once, Write Anywhere(一度習得すれば、あらゆるプラットフォームで開発出来る)

Reactは設計として本体と仮想DOMを実際のUIにレンダリングするレンダラーが分離されている。

# 他のフレームワークとの比較

## Angular

Angularを採用する最大のメリットは、フレームワークとして一通りのものがフルスタックで提供されている点。
保守性を考えるならAngularはいい選択肢。

Reactの早い進化に付き合うのが難しい人・組織はAngularを採用しがち、、らしい。

「[Made with Angular](https://www.madewithangular.com/)」で Angular 製のサイトを見ることが出来る。
ドイツ銀行、デルタ空港、BMW、etc...保守的な大企業に人気。

## Vue.js

名前の由来は「view」のフランス語に相当する「vue」から。

Vue.jsはフレームワークを構成する一貫した思想がない。

日本ではRailsの影響でサーバーサイドのパラダイムから頭を切り替えられない人が多い。
model と view テンプレートが大好きなので、、、
