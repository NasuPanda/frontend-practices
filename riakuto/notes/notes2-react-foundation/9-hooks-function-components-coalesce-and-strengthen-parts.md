# 9. Hooks、関数コンポーネントの合体強化パーツ

# 9-1. Hooks に至るまでの物語

## 手軽ながら壊れやすかった Mixins

2013年に公開された当初のReactではコンポーネントはクラスしかなく、しかもそれを通常のクラス定義ではなく `React.createClass` というメソッドを使って生成するようになっていた。
その引数はオブジェクト。 `render` メソッドなどのそのプロパティとして実装していく形だった。
そして、 `mixins` というプロパティでそのコンポーネントに追加したいクラスメンバーを任意のオブジェクトに格納して登録出来た。それが mixins という手法。

mixinsの問題点

- コンポーネントとの間に暗黙的な依存関係を持ってしまう
  - ミックス先コンポーネントに特定の名前の props, state, メソッド 等があることを前提とした記述になりがち
- 名前の衝突が起きやすい
- ある mixin は 他の mixin に依存するようになり、どれか一つを削除すると他の mixin が壊れるような事態が生じがち

## コミニティにより普及したHOC

HOC =Higher Order Component で、日本語では **高階コンポーネント** 。
HOC とはコンポーネントを引数ニトリ、返り値としてコンポーネントを返す関数のこと。

```ts
type Props = {target: string};
const HelloComponent: FC<Props> = ({target}) => <h1>hello {target}</h1>;

export default withTarget(HelloComponent);

// 呼び出し
const withTarget = (WrappedComponent: FC<Props>) => WrappedComponent({target: 'Parry'});
```

`withTarget` はコンポーネントを受け取り `target` の実体を注入したコンポーネントを返す関数、
すなわち高階コンポーネント。

## Hooksの対抗馬 Render Props

軒並みメジャーなライブラリのインターフェースとして採用され、Recompose が普及して一世を風靡したといっていい HOC だったが、公式はほどなく HOC を推すことをやめ、別の新しい手法を推奨するようになった。
それが Render Props と呼ばれるパターン。

コンポーネントが React Elements を返す関数を props として受け取り、それを自身のレンダリングに利用する。
厳密には受け渡されてレンダリングに使われる props の方を指す言葉。

## Hooks の登場

HOC や render props が共通して抱えていた問題は、ロジックの追加が著しくコンポーネントツリーを汚染してしまうこと。
追加するロジックの分だけコンポーネントの階層が深くなってしまう。

また、HOC も render props も状態を持つロジックを分離はできても、積極的に再利用出来るほどには抽象化出来なかった。

Hooks はコンポーネントにロジックを抱えた別のコンポーネントをかぶせるのではなく、コンポーネントシステムの外に状態やロジックを持つ手段を提供した。
状態を持ったロジックを完全に任意のコンポーネントから切り離し、それ単体でテストしたり、別のコンポーネントで再利用することが簡単にできるようになった。

React が根本的に抱えていた大きな問題の1つに、クラスコンポーネントの存在がある。
React にとっての理想のコンポーネントは純粋関数であるはずなのに、 state やライフサイクルメソッドはクラスコンポーネントしか持つことが出来なかったため、クラスコンポーネントを使わざるを得なかった。
しかし、Hooks がコンポーネントシステムの外に状態やロジックを保つ仕組みを提供したため、ほぼ関数コンポーネントだけでアプリケーションを作れるようになった。

### Hooks の由来

コンポーネントに外から状態やロジックを紐付ける、つまり「引っ掛けて」おく仕組みを提供するというニュアンス。
引っ掛けておけば、後は React が然るべきタイミングで然るべき処理をしてくれるので、 React らしい宣言的な手法と言える。
